# 关键字

extern

- 多文件共享变量，所有文件都可见的全局变量
- extern "C" 会指示编译器这部分代码按 C 语言（而不是 C++）的方式进行编译

static

- 静态全局变量。保存在全局数据区，只在文件内可见
- 静态局部变量。保存在全局数据区，不会随函数退出而销毁.函数多次调用也能访问一样的值；
- 静态函数。只在文件内可见
- 面向对象的静态变量和静态函数。属于类，通过类的作用域访问

explicit

- 声明为 explicit 的构造函数不能在隐式转换中使用

const

- int a = 8;const int \* const p = &a; （左定值，右定指针方向）
- 修饰类成员函数，防止修改类成员变量

cast

- static_cast: 基类和子类之间转换，基本数据类型，指针类型和空指针互转（void*，int*），不能用于指针类型的转换（int * 转double *）
- dynamic_cast: 基类和子类之间转换 + 多肽检查（是否实现了虚函数）
- const_cast: form a reference or pointer to non-const type
- reinterpret_cast 强转换任意类型

重载 覆盖 改写

- Overload（重载）：同一个类里面，名称完全相同、参数不相同
- Override（覆盖）：虚函数
- Overwrite（改写）：子类声明一个和父类名字参数一样的函数。需要通过父类的作用域才能调用父类的函数

# 类 class

多态
- 编译时多态：根据不同参数调用不同的函数（函数重载和运算符重载）。
- 运行时多态：父指针可以调用子类对象的虚函数（函数覆盖）
    - 实现原理：覆盖虚函数表的函数指针。
    - 构造函数会创建虚指针，虚指针地址上存放虚函数表的地址。虚函数表存放了函数指针。虚函数表地址的上一个地址存放了 type info
    - 析构函数需要是虚函数
    - 菱形继承： 通过虚继承解决。虚基类只被继承一次

构造函数
- 拷贝构造函数里，实参到形参有一次拷贝（形参在构造函数的栈里面），然后调用一次赋值构造函数
- 拷贝构造函数的参数必须不能是值传递（值传递会调用拷贝构造函数,死循环）
- 类定义引用成员变量，必须用初始化列表来构造。
  - 初始化列表：在类外调用一次拷贝构造函数，来给成员赋值。 如果在构造函数里面构造，那么函数结束时会销毁，导致引用报错

析构函数
- 不能抛出异常。函数退出时候，对象会析构，但函数已经退出。

友元函数

- 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员

# 容器和算法库

- 顺序容器： 数据的地址是按顺序的，数组，列表，deque
- 关联容器：二叉树，哈希表

- 迭代器失效
  - 遍历容器时，顺序容器在删除元素时会移动数据，从而导致失效

数据结构

- map，set
  - key 有序 平衡二叉树（红黑树）
- unordered_map， unordered_set
  - key 无序，哈希表
  - 哈希表：解决冲突： 拉链法，开放地址法
- multimap，multiset
  - 允许相同 key，有序
- vector
  - 数组
  - reserve 预留空间但不改变大小，空间不够则重新创建数组
  - resize 改变数组大小，填充数组
- list
  - 双向链表
- deque

  - 指针数组，首尾插入 o(1)

- 内存分配器

  - 大于 128 bytes, malloc()
  - <=128 bytes, 内存池， array of list， 每个 list 都是由 8bytes 倍数的内存块组成

- 仿函数

  - 类重载括号运算符()， 好处：类有成员变量，函数没有

- 模版函数 sort，transform， copy_if

# 智能指针

- uniq_pointer.只有一个对象管理指针
- share_pointer.多个对象管理指针，维持计数
- weak_pointer. 防止 share_pointer 互相引用，导致无法删除

# 锁

mutex

- 悲观锁
- 锁获取失败后会挂起线程，需要内核调度线程,适用于竞争冲突多的场景
- 条件变量。阻塞线程直到被通知

CAS

- 自旋锁 乐观锁
- 轮循， 线程不会挂起，节省线程调度消耗，适用于竞争冲突少的场景。冲突多，长期不挂起，浪费 cpu
- compare_exchange_weak:
  - this 和 expected 比较，不相等时，this 赋值给 expected。相等时，desired 赋值给 this 即使相等，偶尔返回错，使用于需要 loop 的算法

# 设计模式

单例模式

- 懒汉 使用时才初始化 加锁
- 饿汉 程序运行时初始化，没锁

生产者消费者模式

# 内存分配

- new: 参数是类名，
- malloc： 参数是内存大小，不会调用构造析构函数
- placement new 在预先分配内存上构造
- 内存对齐。cpu 只能从固定地址获取指令，内存对齐避免 cpu 执行多次指令获取数据

# 协程

用处：实现代码跳转

原理：保存上下文，例如 rsp rbp rip，维护协程的内存空间

# 编译处理

- 预编译。 包括宏（#define）文件处理（#include） 条件编辑（#ifndef x ）
- 编译。 生成汇编代码
- 汇编。 汇编代码生成机器指令，生成目标文件
- 链接。 链接目标文件，生成可执行文件
