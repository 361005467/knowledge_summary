# 基于 redis 实现分布式锁的方案总结

## 文章会从最基本的方案逐步演进

**方法 1**

多个用户进程同时访问一个相同的 key，若 key 的值为 false，则代表未上锁。然后将值设置为 true

**缺陷 1**

如果获取锁的用户进程挂掉，则无法释放锁

**方法 2**

设值时，加入过期时间。这样用户进程挂掉后也能自己释放

**缺陷 2**

如果用户进程的任务执行时间超过过期时间，则会提早释放锁导致问题

**方法 3**

github 有个叫 redisson 的库提供了一个解决思路。 每当进程获取锁后，会开启一个线程定时延长锁的失效时间，直到任务完成。这样在任务执行时，锁永远不会失效，而当用户进程挂掉时，则延长失效时间的线程也会随之挂掉

**缺陷 3**：redis 在分布式部署下，无论是哨兵模式还是 cluster 模式，主从机器的数据拷贝都是异步的。这意味着一旦主机挂掉，从机是无法保证数据跟主机一致。在上面的方案上，如果主机的值是 true，从机的值是 false(没来得及同步)，一旦主机挂掉，就会存在多个进程获得锁的情况

**方法 3**

redis 作者在官网上提及到了上述问题，并且提出来了名为 redlock 的方案。作者认为此方案下，只要大部分机器还存活时，则可以保证锁的正确性。 这里大部分机器指的是：master 机器数的一半+1， 如果有 5 台 master 机，那只要有 3 台机存活就足够。

方案思路大概如下：

进程要想获取锁，必须向集群的大部分机器查询同一个 key 的值是否为空，若都为空，则可以获取锁并赋值为 true. 当然，该方案还提及到一些细节，例如时间失效，设值时要带上进程的唯一标识

上述方案看上去确实是保证了锁的正确性，但明显性能很低。但从性能的角度看，高性能的设计是不应该用到锁。锁是表明了多进程对同一资源的争夺。而同一资源的争夺必定成为链路瓶颈，多进程并行处理并没有意义。因此串行处理反而节省了各种锁的开销，性能更高

## 总结

文章描述了如何基于 redis 设计分布式锁，并讨论了过期失效和主机崩溃的场景和对应的解决方案。 上述方案只是属于讨论状态，本人还没应用到实际场景当中。
