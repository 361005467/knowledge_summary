# 概述

抽奖和秒杀都会有限额，例如只有十个抽奖礼品或者十个特价礼品。因此处理请求时，都需要高并发查询和修改限额。本文会讨论处理这种场景的技术方案

## 限流处理

- 对于用户的请求进行异步处理

接收到用户请求后直接回复稍后通知，然后把请求放进队列进行异步处理。这样做的好处是可以迅速响应请求，并且可以利用队列控制处理速度，减缓对数据库造成的压力

## 并发处理

- 将每个礼品的请求放进独自的一个队列，并只允许单个消费者进行串行处理

因为修改查询限额只能串行操作，并发处理只会造成没有意义的锁等待。 修改查询限额可以使用 mysql 或者 redis

mysql 方式：

```
START TRANSACTION

result = query(SELECT * FROM gift_table WHERE gift_id = 'iphone_id' FOR UPDATE)

if result.counter > 0 {
    UPDATE gift_table SET counter=counter-1 WHERE val > 0 limit 1
}


COMMIT
```

redis 方式

```
if decrby(gift_counter_key) > 0 {
    process
}
```

## 数据准确性的容灾处理

- 基于数据库强一致性进行容灾

上述提及到的 mysql 和 redis 处理方式，需要考虑数据库主机 crash 导致数据不一致的情况。例如在主从架构上，主机 crash 导致数据没及时同步到从机，然后从机升级为主机后，永久丢失了数据。数据库需要提供**强一致性**，才能保证限额的准确性。

然而 redis 开源版本仅仅支持主从模式下的异步拷贝，无法确保主机 crash 下的数据准确性。腾讯云的 redis 提供了一个基于 raft 协议的强一致性版本.

而对于 mysql，要保证强一致性有两个做法：全同步复制和基于 paxos. 全同步复制需要所有丛机写入才响应客户端，效率较低。而基于 paxos 的算法则只需要过半数主机的确认。

- 基于多重保险容灾

如果靠数据库的强一致性来保证数据准确，会导致数据库的使用成本上升以及降低了处理的效率。据了解，一般金融产品才会使用这种高成本到数据库。因此，这里会提供另外一个思路：通过多次验证限额的正确性来允许数据库的灾难发生。 具体来说，可以把限额写进两个数据库，例如同时写入 redis 和 mysql。限额查询时发现数据不一致时，取最小值作为限额并触发告警通知到开发者。通过这种多重保险的手段，可以降低异常的风险，但不能完全避免。此时开发者可以权衡礼物超发后的代价和数据库使用成本后再做选择
