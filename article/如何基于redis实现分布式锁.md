# 基于 redis 实现分布式锁的方案总结

## 概述

文章会从最基本的方案逐步演进讨论

**方法 1**

多个用户进程同时访问一个相同的 key，若 key 的值为 false，则代表未上锁,然后将值设置为 true. 解锁时则删除 key. 由于 redis 是单线程模型，所以不用考虑并发场景下的冲突问题

**缺陷**

如果获取锁的用户进程挂掉，则无法释放锁

**方法 2**

获取锁时，加入过期时间。这样用户进程挂掉后，锁也能自动释放

**缺陷**

如果用户进程的任务执行时间超过锁的过期时间，则会提早释放锁

**方法 3**

github 有个叫 redisson 的库提供了一个解决思路。 每当进程获取锁后，会开启一个线程定时延长锁的失效时间，直到任务完成。这样在任务执行时，锁永远不会失效，而当用户进程挂掉时，则延长失效时间的线程也会随之挂掉

**缺陷**

redis 在分布式部署下，无论是哨兵模式还是 cluster 模式，主从机器的数据拷贝都是异步的。这意味着一旦主机挂掉，从机是无法保证数据跟主机一致。在上面的方案上，如果主机的值是 true，从机的值是 false(没来得及同步)，一旦主机挂掉，就会存在多个进程获得锁的情况

**方法 4**

改造 cluster 的主从异步数据拷贝模式，让其支持强一致性。腾讯云的 redis 通过 raft 协议支持了强一致性

**方法 5**

redis 作者在官网上也提及了主从数据丢失的问题，并且提出来了名为 redlock 的方案。作者认为此方案下，只要大部分机器还存活时，则可以保证锁的正确性。 这里大部分机器指的是 master 机器数的一半+1， 如果有 5 台 master 机，那只要有 3 台机存活就足够。

方案思路大概如下：

进程要想获取锁，必须向集群的大部分机器查询同一个 key 的值是否为空，若都为空，则可以获取锁并赋值为 true. 当然，该方案还提及到一些细节，例如时间失效，设值时要带上进程的唯一标识

上述方案看上去确实是保证了锁的正确性。但由于需要客户端多次请求，所以性能是很低的。但从性能的角度看，高性能的设计是不应该用到锁。锁是表明了多进程对同一资源的争夺。而同一资源的争夺必定成为链路瓶颈，多进程并行处理并没有意义。因此串行处理反而节省了各种锁的开销，性能更高

## 总结

文章描述了如何基于 redis 设计分布式锁，并讨论了过期失效和主从数据不同步的场景
