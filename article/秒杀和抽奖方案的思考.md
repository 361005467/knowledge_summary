# 概述

抽奖和秒杀都会有限额，例如只有十个抽奖礼品或者十个特价礼品。因此处理请求时，都需要高并发查询和修改余额。本文会从限流，并发，数据一致性,缓存,安全策略的角度来展开讨论

## 限流处理

抽奖和秒杀都有瞬时并发的场景。如果没控制好流量，会导致服务不可用或者数据库不可用。下面会讨论几种限流处理方案。

1.  前端限流：错开活动时间和随机不处理

    如果业务允许非绝对的公平性，前端可以进行一些柔性策略：

    - 用随机数稍微错开秒杀活动的开始时间。
    - 随机放弃请求，直接告诉用户失败。

2.  后端请求限流

    - 后端可以根据 cpu 负载和 qps 处理能力来拒绝请求。

    - 随机抛弃请求

3.  队列限流

    - 对用户的请求进行异步处理。接收到用户请求后直接回复稍后通知，然后把请求放进队列进行异步处理。这样做的好处是可以迅速响应请求，并且可以利用队列控制处理速度，减缓对服务器和数据库的压力。

4.  数据库限流

    - 对于秒杀场景，每个礼品都会有限额，这意味着我们只需要处理固定数量的请求。 例如限购 100 部特价 iphone，那么每秒只需要处理 100 个查询数据库端的请求，其余请求可以直接返回失败给客户端。这里的数据库请求计算可以使用 redis 来处理

    - 有同学可能会在这里疑惑，查询数据库请求数和查询限额数都是查询数据库，为什么就会降低对数据库的压力呢？ 这样做的原因是查询限额是需要保持绝对准确，防止超发，因此需要高成本一点的查询，这个下面会详细论述。而这个数据库限流的计数不需要追求绝对准确，即使数据库在主机 crash 导致主从不同步的情况下，也是可以接受的

## 并发处理

处理最关键的点是查询修改商品的余额。由于余额数是一个单点数据，所有请求都会访问，因此是个瓶颈点。下面会展开讨论方案

1.  将每个礼品的请求放进独自的一个队列，并只允许单个消费者进行串行处理

    因为修改查询限额只能串行操作，并发处理只会造成没有意义的锁等待。 修改查询限额可以使用 mysql 或者 redis

    mysql 方式：

    ```
    START TRANSACTION

    result = query(SELECT * FROM gift_table WHERE gift_id = 'iphone_id' FOR UPDATE)

    if result.counter > 0 {
        UPDATE gift_table SET counter=counter-1 WHERE val > 0 limit 1
    }
    ```


    COMMIT
    ```

    redis 方式

    ```
    if decrby(gift_counter_key) > 0 {
        process()
    }
    ```

    mysql 的存储介质是磁盘，查询修改是 o(n),有索引情况下是 o(lgn)。而 redis 是内存数据库，查询理论上 o(1). 因此 redis 更高效。

2.  拆分商品，从而降低数据库操作压力

    在 redis 场景下，对于限额 10000 部的特价 iphone，它的 key value 可以表示成 r_iphone:10000. 然而所有请求都落到单一 key 的查询时，这就成了单点的瓶颈。因此
    我们可以把它拆成多个商品来存储，例如 r_iphone_1:10, r_iphone_2:10 来处理. 这里的拆分可以按地区或其他纬度拆分，取决于业务逻辑.

## 数据准确性的容灾处理

余额计算需要保证绝对的准确性，否则会引起超发。

1.  基于数据库强一致性进行容灾

    上述提及到的 mysql 和 redis 处理方式，需要考虑数据库主机 crash 导致数据不一致的情况。这里先简单介绍数据库的一些知识点

    **强一致性**：每次读都能读到最新的数据，主机崩溃后，从机能升级成主机，并保证数据完备。paxos 和 raft 算法可以保证强一致性。raft 算法只要把写操作同步到过半数的机器，则可以 commit 数据，向客户端返回确认。并且通过选举机制，在主机崩溃下，重新选择主机，保证不丢失数据。腾讯云的 redis 提供了基于 raft 的强一致性版本，而 phxsql 则是提供了基于 paxos 实现的强一致性版本

    **异步拷贝数据**：当客户端发送数据到主机时，主机把数据写入后，会马上向客户端确认，随后会异步地把数据拷贝到从机。如果拷贝完成前主机崩溃，那数据会永久丢失. 开源版本的 redis 和 mysql 都提供了这个方案。

    可以看出来，要保证余额计算的准确性，我们需要用到强一致性的数据库。异步拷贝的方案在主机崩溃的情况下会产生计算错误。

2.  基于多重保险容灾

    如果靠数据库的强一致性来保证数据准确，会导致数据库的使用成本上升以及降低了处理的效率。据了解，一般金融产品才会使用这种高成本到数据库。因此，这里会提供另外一个思路：通过多次验证限额的正确性来允许数据库的灾难发生。 具体来说，可以把限额写进两个数据库，例如同时写入两个独立部署的 redis。限额查询时发现数据不一致时，取最小值作为限额并触发告警通知到开发者。通过这种多重保险的手段，可以降低异常的风险，但不能完全避免。此时开发者可以权衡礼物超发后的代价和数据库使用成本后再做选择

## 缓存处理

用户必然会高频查询商品的余额， 因此要通过缓存避免请求直接落到数据库。然而缓存会牺牲掉数据更新的及时性。

1.  前端缓存

    前端每隔一段时间才会发起请求查询。

2.  后台进程缓存

    进程每隔一段时间从数据库获取余额，并缓存到进程缓存里。请求只会返回进程缓存的结果。这里要同一时间点不同进程的余额缓存会出现偏差。

3.  集中式缓存，redis

    每隔一段时间从数据库获取余额，更新到 redis。请求只会从 redis 获取缓存结果。

    不同级别的缓存会造成不同级别的数据延时性和准确性。业务可以根据负载情况下进行分级处理

## 安全策略

涉及到钱的时候，就会有恶意请求。因此，需要制定安全策略来阻止

1.  限制单用户访问频率
2.  限制 ip 访问频率
3.  限制用户获取奖励的总值，禁止用户互赠礼品
4.  对获奖用户的活跃度进行判断。对低活跃度用户进行验证

# 总结

本文从限流，并发，数据一致性，缓存以及安全的角度来展开讨论抽奖/秒杀高并发场景的处理方案。
