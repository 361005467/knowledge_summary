# 概述

在微服务的大潮下，分布式事务屡见不鲜. 举个例子，用户转账 100 块给商户。当用户的扣费服务和商户的转账服务属于单独两个服务时，要怎样才能保持两个操作同时成功或者同时取消。换句话说，如何保证任务集合里的所有任务同时成功或同时取消

本文会从零开始逐步演进，讨论一个基于异步处理实现的最终一致性方案

## 单个任务状态

对于单个任务的状态，有以下三种情况

- 成功
- 失败
  - 当任务失败时，可进行有限次数的重试。超过次数时，则对所有任务进行回滚。回滚重试多次失败时，则记录并进行告警，等待修复
- 超时
  - 超时可能是任务已经处理成功，但回包失败。这种场景，我们只能对任务进行重试，重试多次后，标记为失败状态。任务处理需要保证幂等性，防止多次处理

## 任务处理的幂等性和可回滚

从对任务状态的讨论得知，任务需要保证：

1. 幂等性：对于相同的订单号不会重复处理

2. 可回滚：提供回滚接口，通过订单号即可回滚对应修改

## 任务集合持久化和五个状态

从直觉上，我们也许会相处以下方案：

    用户发起转账请求，业务进程收到后，分别向扣费服务和转账服务发起请求。当任意一个服务处理失败时，则对服务进行有限次数的重试。 当超过重试次数时，对所有业务回滚

然而该方案下，当业务进程奔溃时，则会丢失目前的处理状态。例如已经处理扣费但转账失败。执行回滚前，进程崩溃了，从而丢失目前的处理状态

为了保存当前处理状态，我们可以将任务集合和处理状态保进行持久化，这里可以选用数据库。有了这张任务表后，我们可以安排进程不断从表里获取要处理的任务。在数据表里，任务集合有五个状态

- 未处理
- 处理中
  - 任务集合在进行处理
- 已超时
  - 任务集合在处理，但处理超过预设时间。超时有两个可能性，第一是进程已经崩溃，第二是进程还在处理。 如果进程业务对各个微服务调用有严格的超时限制，则可以避免第二种还在处理的情况。
  - 对于已超时的任务集合，需要有新的业务进程进行重试处理。 由于我们要求任务处理幂等性，所以就算有多个业务进程多次处理，也不会影响正确性
  - 这里的超时计算需要有独立的进程来维护
- 已完成
  - 任务集合里所有任务全部完成或者全部取消
- 部分失败
  - 这里指的是集合当中有回滚失败的。对于回滚失败的任务，需要进行告警并修复。部分失败状态的任务集合会定时进行重试，直至已完成状态

到此，我们就推理出了一个实现分布式事务的异步方案，该方案只能保证最终的一致性，但优点是不要求各业务的及时处理。对于异常任务，只要修复完成，整个任务集合就可以自动恢复到一致性状态，不需要人工干预

## 总结

该方案先是通过对任务集合持久化和超时处理来防止业务进程崩溃导致的任务丢失问题。其次，通过业务处理的幂等性，可回滚，和多次重试，从而保证任务集合的最终一致性
