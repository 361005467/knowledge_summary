# 概述

在微服务的大潮下，分布式事务屡见不鲜. 举个例子，用户转账 100 块给商户。当用户的扣费服务和商户的转账服务属于单独两个服务时，要怎样才能保持两个操作同时成功或者同时取消. 换句话说，如何保证任务集合里的所有任务同时成功或同时取消

本文会从零开始逐步演进，讨论一个基于异步处理实现的最终一致性方案。

对于单个任务的状态，有以下三种情况

- 成功
- 失败
  - 当微服务失败时，可进行有限次数的重试。超过次数时，则对所有业务进行回滚。回滚重试多次失败时，则记录并进行告警，等待修复。
- 超时
  - 超时可能是微服务已经处理成功，但回包失败。这种场景，我们只能对服务进行重试，重试多次后，标记为失败状态。业务需要保证接口的幂等性，防止多次处理

从对任务状态的讨论得知，我们需要保证处理：

1. 接口的幂等性。对于相同的订单号不会重复处理

2. 业务可回滚。提供回滚接口，通过订单号即可回滚对应修改

下面会逐步讨论方案并演进

用户发起转账请求，服务端收到后，分别向扣费服务和转账服务发起请求。当任意一个服务处理失败时，则对服务进行有限次数的重试。 当超过重试次数时，对所有业务回滚
  
然而，当服务端自身奔溃时，则会丢失目前的处理状态。例如已经处理扣费但转账失败。执行回滚前，服务端崩溃了，从而丢失目前的处理状态

为了保存当前处理状态，我们可以将任务集合和处理状态保进行持久化，这里可以选用数据库。有了这张任务表后，我们可以安排进程不断从表里获取要处理的任务。在数据表里，任务集合有五个状态

- 未处理
- 处理中
  - 业务进程已经从表里获取任务集合并进行处理
- 已超时
  - 业务进程已经从表里获取任务集合并进行处理，但处理超过预设时间。超时有两个可能性，第一是进程已经崩溃，第二是还在处理。 如果进程业务对各个微服务调用有严格的超时限制，则可以避免第二种还在处理的情况。
  - 对于已超时的任务集合，业务进程需要进行重试处理。 由于我们要求任务处理幂等性，所以就算有多个业务多次处理，也不会影响正确性
  - 这里的超时计算需要有独立的进程来维护
- 已完成
  - 任务集合里所有任务全部完成或者全部取消
- 部分失败
  - 这里指的是集合当中有回滚失败的。对于回滚失败的任务，需要进行告警并修复。部分失败状态的任务集合会定时进行重试，直至已完成状态

到此，我们就推理出了一个实现分布式事务的异步方案，该方案只能保证最终的一致性，但优点是不要求各业务的及时处理。总结一下，该方案先是通过对任务集合持久化和超时处理来防止业务进程崩溃导致的任务丢失问题。其次，通过业务处理的幂等性，可回滚，和多次重试，从而保证任务集合的最终一致性
