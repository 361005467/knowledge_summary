# 概述

在微服务的大潮下，分布式事务屡见不鲜. 举个例子，用户转账 100 块给商户。当用户的扣费服务和商户的转账服务属于单独两个服务时，要怎样才能保持两个操作同时成功或者同时失败.

本文会从零开始逐步演进，讨论一个基于异步处理实现的最终一致性方案。

对于单个业务的状态，有以下三种

- 成功
- 失败 - 当业务失败时，可进行有限次数的重试。超过次数时，则对所有业务进行回滚。回滚多次失败时，则记录并进行告警
  超时
- 超时可能是业务已经处理成功，但回包失败。这种场景，我们只能对业务进行重试。业务需要保证接口的幂等性，防止多次处理

从对业务状态的讨论得知，我们需要保证处理处理接口的幂等性，也就是对于相同的订单号不会重复处理。同时，也要提供回滚处理接口。通过订单号即可回滚对应修改

下面会逐步讨论方案并演进

- 方案 1
  用户发起转账请求，服务端收到后，分别向扣费服务和转账服务发起请求。当任意一个服务处理失败时，则对服务进行有限次数的重试。 当超过重试次数时，对所有业务回滚

然而，当服务端自身奔溃时，则会丢失目前的处理状态。例如已经处理扣费但转账失败。执行回滚前，服务端崩溃了，从而丢失目前的处理状态

- 方案 2
  为了保存当前处理状态，我们可以将处理任务和处理状态保存到数据库。这里我把它命名为任务状态表。有了这张表，我们可以安排进程不断从表里获取要处理的任务并标记状态。

状态可以分为四种

- 未处理
  -
- 处理中
- 已超时
- 已完成
