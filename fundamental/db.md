# 索引

聚簇索引：

- 目的：减少磁盘 io。
- 方法：让结点存尽可能多的索引值，撑满磁盘块大小，从而降低树的高度，降低磁盘 io。
- 中间结点只存索引值，叶子结点存所有行数据

非聚簇索引：

- 叶子点是主键

innodb 主键索引是聚集索引，（二级索引）辅助索引是非聚簇索引

为什么辅助索引叶节点是主键而不是行指针？数据插入时，数据移动，行指针会变，主键不会，不需要大幅度更新辅助索引

自增 id 做主键，插入的时候直接放在最后。否则插在中间引起数据重排

## b+树

b+树叶子点保存所有数据，b 树在中间节点保存数据
b+树优点

- b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素
- 对于范围查找来说，b+树只需遍历叶子节点链表

# mysql

ACID

- a：原子性，全部成功或失败
- c： 数据一致性
- i 事务之间的隔离性
- d commited 后必须持久化

隔离级别

- read uncommitted: 未 commit 的数据也能读
  - 产生脏读：读了未 commit 并且 rollback 的数据
- read commited: commit 过的数据就能读.每次读都生成快照
  - 产生不可重复读：读同一条数据两次结果不一样
  - 产生幻读： 前后两次 select，第二次比第一次多了数据（用 间隙锁 解决）
- repeateable read: 开始事务时，生成快照，数据都从快照读
- serailization： 加锁

MVCC：通过数据版本来处理并发场景。 每条数据都会有历史版本。

快照生成: 查版本链，找自己版本小但最大的版本

- read commited： 每次 select 都取快照，
- repeateable read： 开启事务的时候取快照
- 快照读，读快照的数据
  - 简单的 select 操作(不包括 select ... lock in share mode, select ... for update)
- 当前读：读最新，加锁
  - select ... lock in share mode，select ... for update

锁

- 表锁：innodb 上，没索引就锁全表
- 行锁：innodb 上，设置索引的字段可以加行锁
  - Record Lock：单个行记录上的锁
  - Gap Lock：间隙锁（行之间的锁）。锁定一个范围，但不包括记录本身。目的，是为了防止同一事务的两次当前读，出现幻读的情况
  - Next-Key Lock：前两个锁的结合，解决幻读
- 意向锁：便于查询表里是否已经加了行锁

* 悲观锁
  - select for update
  - 颗粒度大，性能弱
* 乐观锁
  - 增加版本字段，写之前先比较
  - 只适合并发少的场景

数据扩展

- 分表
  - 单数据库建多张表，要考虑查询排序问题
  - 尽量让查询落在单表
- mysql paritition 分区
  - 对应用层来说是一张表，mysql 自动划分存储。
- 分库
  - 分到多个数据库
- 分片 sharding
  - 多主机保存数据，要考虑事务场景
  - mongo 内置 sharding，会自动分布式查询， mysql 需要应用层实现
- 副本集 replica set 数据冗余

mysql 注入

- 问题：用户参数混入恶意命令
- 解决：禁止参数带有非法字符(or,--)

log

undo log：

- 保持数据历史版本，用于回滚和快照读

redo log：

- 提高写性能：执行事务，先写 redo log，再写 buffer。系统空闲时，再把 buffer 刷进磁盘
- 保证事务一致性。执行事务前先写 redo log，记录事务的状态，用于故障时恢复
- 循环写，旧数据会被覆盖

binlog：

- 事务提交时，将写操作写进 binlog。
- 用于主从复制，历史数据恢复

# redis

基本结构

- 字符串
- 哈希，开链法，桶+链表
- 链表
- 集合
- 有序集合：跳表，二分查找链表。 相比红黑树，跳表支持高效范围查询 o（logn）

rehash

- 重新建桶，把链表重新划分到不同的桶
- 时机：1.当读写数据时，移动对应的桶 2.定时任务

过期删除 timeout

- 数据结构：过期字典
- 时机：1. 当读/写一个已经过期的 key 时，直接删除掉这个过期 key 2.定时任务

数据淘汰

- 多种淘汰策略，例如 lru，哈希+双向链表

持久化

- aof：以日志的形式记录服务器所处理的每一个写操作
  - 重写：当文件太大时，根据数据重写操作记录
- rdb： fork 一个子进程，保存整个数据集

数据扩展

- 哈希槽： 分成 2^14 个槽，每个 master 分配一定数量的槽，路由表存在客户端
- 一致性哈希：机器 ip 求 mod，key 求模后找最近的机器 ip mod

分布式部署

- 主从 1 主多从
- 哨兵 1 主多从+监控，切换故障 master
- 集群 多主多从
- 故障会导致数据丢失，主从不一致
