# 索引

聚簇索引：

- 目的：减少磁盘 io。
- 方法：让结点存尽可能多的索引值，撑满磁盘块大小，从而降低树的高度，降低磁盘 io。
- 中间结点只存索引值，叶子结点存所有行数据

非聚簇索引：

- 叶子点是主键

innodb 主键索引是聚集索引，（二级索引）辅助索引是非聚簇索引

为什么辅助索引叶节点是主键而不是行指针？数据插入时，数据移动，行指针会变，主键不会，不需要大幅度更新辅助索引

自增 id 做主键，插入的时候直接放在最后。否则插在中间引起数据重排

## b+树

b+树叶子点保存所有数据，b 树在中间节点保存数据
b+树优点

- b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素
- 对于范围查找来说，b+树只需遍历叶子节点链表

# mysql

ACID

- a：原子性，全部成功或失败
- c： 数据一致性
- i 事务之间的隔离性
- d commited 后必须持久化

隔离级别

- read uncommitted: 未 commit 的数据也能读
  - 产生脏读：读了未 commit 并且 rollback 的数据
- read commited: commit 过的数据就能读.每次读都生成快照
  - 产生不可重复读：读同一条数据两次结果不一样
  - 产生幻读： 前后两次 select，第二次比第一次多了数据（用 Next-Key Lock 解决）
- repeateable read: 开始事务时，生成快照，数据都从快照读
- serailization： 加锁

MVCC：通过数据版本来处理并发场景。 每条数据都会有历史版本。

快照生成: 查版本链，找自己版本小但最大的版本

- read commited： 每次 select 都取快照，
- repeateable read： 开启事务的时候取快照
- 快照读，读快照的数据
  - 简单的 select 操作(不包括 select ... lock in share mode, select ... for update)
- 当前读：读最新，加锁
  - select ... lock in share mode，select ... for update insert，update，delete

锁

- 表锁：innodb 上，没索引就锁全表
- 行锁：innodb 上，设置索引的字段可以加行锁
  - Record Lock：单个行记录上的锁
  - Gap Lock：间隙锁（行之间的锁）。锁定一个范围，但不包括记录本身。目的，是为了防止同一事务的两次当前读，出现幻读的情况
  - Next-Key Lock：前两个锁的结合，解决幻读
- 意向锁：便于查询表里是否已经加了行锁

* 悲观锁
  - select for update
  - 颗粒度大，性能弱
* 乐观锁
  - 增加版本字段，写之前先比较
  - 只适合并发少的场景

数据扩展

- 分表
  - 单数据库建多张表，要考虑查询排序问题
  - 尽量让查询落在单表
- mysql paritition 分区
  - 对应用层来说是一张表，mysql 自动划分存储。
- 分库
  - 分到多个数据库
- 分片 sharding
  - 多主机保存数据，要考虑事务场景
  - mongo 内置 sharding，会自动分布式查询， mysql 需要应用层实现
- 副本集 replica set 数据冗余

mysql 注入

- 问题：用户参数混入恶意命令
- 解决：禁止非法字符(or,--)

# 分布式

CAP 理论：分布式系统中，分区网络错误的情况下，可用性，一致性只能二选一

- 分区容忍性：允许系统节点之间的网络发生故障
- 一致性：只要写入成功，后续的所有读操作，都会读到最新的数据；在故障时，读到错误
- 可用性：每次读都能读到数据（非错误信息），但不保证一致性

由于分区网络错误是必然发生对，所以要根据业务场景选择一致性或者可用性。这里的一致性指的是强一致性

base 理论：基本可用，软状态，最终一致性

- 基本可用：和 cap 的可用性一样
- 软状态：允许各节点的数据在中间时刻不一致，也就是不能保证强一致性
- 最终一致性：写成功后，只需要保证在若干时间后的所有读操作能读到最新的数据

base 理论就是 cap 理论下选择了可用性，然后提供了最终一致性而不是强一致性

一般在金融服务里，我们才需要这种强一致性。在 to c 业务里，很多场景只需要保持最终一致性，例如发评论，过一会才看到也是可以的

下面分析下各数据库下的一致性和可用性

mysql

- 全同步复制： 所有从节点写入成功便返回
- 异步复制： 不需要从节点确认，直接返回
- 半同步复制： 一个从节点成功写入 relay，即刻返回
- MGR(mysql group replication)， 基于 paxos。

paxos

- 主机故障时， 通过超半数投票确认来重新选主
- 强一致性。在从节点读也能保证强一致性读

全同步/异步/半同步保证了可用性牺牲了一致性，而 MGR
保证了强一致性，牺牲可用性

mongodb
保证了最终一致性和可用性

redis
开源版本保证了可用性牺牲了一致性

# redis

基本结构

- 字符串
- 哈希，开链法，桶+链表
- 链表
- 集合
- 有序集合：跳表，二分查找链表。 相比红黑树，跳表支持高效范围查询 o（logn）

rehash

- 重新建桶，把链表重新划分到不同的桶
- 时机：1.当读写数据时，移动对应的桶 2.定时任务

过期删除 timeout

- 数据结构：过期字典
- 时机：1. 当读/写一个已经过期的 key 时，直接删除掉这个过期 key 2.定时任务

数据淘汰

- 多种淘汰策略，例如 lru，哈希+双向链表

持久化

- aof：以日志的形式记录服务器所处理的每一个写操作
  - 重写：当文件太大时，根据数据重写操作记录
- rdb： fork 一个子进程，保存整个数据集

数据扩展

- 哈希槽： 分成 2^14 个槽，每个 master 分配一定数量的槽，路由表存在客户端
- 一致性哈希：机器 ip 求 mod，key 求模后找最近的机器 ip mod

分布式部署

- 主从 1 主多从
- 哨兵 1 主多从+监控，切换故障 master
- 集群 多主多从
- 故障会导致数据丢失，主从不一致
