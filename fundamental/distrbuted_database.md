# CAP

CAP 理论：分布式系统中，分区网络错误的情况下，可用性，一致性只能二选一

- 分区容忍性：允许系统节点之间的网络发生故障
- 一致性：只要写入成功，后续的所有读操作，都会读到最新的数据；在故障时，读到错误。这里的一致性也就是强一致性。
- 可用性：每次读，从任意节点读，都能读到数据（非错误信息）

证明

由于分区网络错误是必然发生，所以要根据业务场景选择一致性或者可用性。那为什么两者不能同时兼得？这里来个简单证明。 强一致性读是要保证节点自身能返回最新的数据，那节点如何知道自己是最新的呢？ 有两个方法：1. 由于 master 存储了最新数据，可以选择跟 master 通信获取。2.获取大部分节点的信息，从而确认自己是否有最新数据。 由此可见，强一致性读需要网络通信。在网络错误时候，只有两种选择：1. 直接返回自身的数据，有可能是旧数据。 2. 返回错误，确保了强一致性，放弃可用性

# BASE

base 理论：基本可用，软状态，最终一致性

- 基本可用：和 cap 的可用性一样
- 软状态：允许各节点的数据在中间时刻不一致，也就是不能保证强一致性
- 最终一致性：写成功后，只需要保证在若干时间后的所有读操作能读到最新的数据

base 理论就是 cap 理论下选择了可用性，然后提供了最终一致性而不是强一致性

一般在金融服务里，我们才需要这种强一致性。在 to c 业务里，很多场景只需要保持最终一致性，例如发评论，过一会才看到也是可以的

下面分析下各数据库下的一致性和可用性

mysql

- 全同步复制： 所有从节点写入成功便返回
- 异步复制： 不需要从节点确认，直接返回
- 半同步复制： 一个从节点成功写入 relay，即刻返回
- MGR(mysql group replication)， 基于 paxos。

paxos：提供强一致性的共识算法

- 主机故障时， 通过超半数投票确认来重新选主
- 强一致性。在从节点读也能保证强一致性读

全同步/异步/半同步保证了可用性牺牲了一致性，而 MGR
保证了强一致性，牺牲可用性

mongodb
保证了最终一致性和可用性

redis
开源版本保证了可用性,但在故障时，有可能丢失数据
