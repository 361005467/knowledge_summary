# 数据分片

单数据库处理数据能力有限，因此需要对数据进行划分到多台数据库，每个数据库只存部分数据

# 数据容灾

每个数据库的数据都需要备份到多台机器，以免单一机器故障引起丢失。多台机器存储同样的数据，这就涉及到可用性和数据一致性的问题。从使用方的角度，会关心下面的问题

1. 在正常/网络故障/机器故障下，每次读，从任意节点读，是否都能正常返回数据？
2. 在正常/网络故障/机器故障下，每次读，从任意节点读，是否都能返回所有写操作后的最新数据？还是只能返回旧数据？

对金融服务来说，故障情况下短暂不可用是可以接受的，但返回旧数据是不能接受的。例如扣了 1 万块，再次查询时，返回错误是能接受的，但返回了没扣的数据，是不能接受的。 对于其他业务，例如发评论后，查询时短暂没返回也是可以接受的。

举几个例子说明下为什么会导致上述两个问题：

1. mysql 主从异步复制：主节点提交成功后就算成功，然后从机异步拉取更新数据。

问题：写数据时,主机确认了，但还没同步到从机，主机就故障了。这时候从机升级为主机，丢失了数据。

例子：例如用户有 100 块，转账了 100 块，主机数据库显示用户只剩 0 块。转账时主机故障，数据没来得及同步给从库。此时从库升级为主机，显示用户还有 100 块，用户再次转账，一共转出了 200 块出去，造成业务损失。这就是读数据时，没读到写操作后最新的数据。

2. mysql 半同步复制：主节点先把数据同步到从节点，从节点提交后向主节点确认。主节点收到确认后，提交，然后确认写操作提交成功

问题：从节点提交成功后，从节点故障了，向主节点的确认包也丢失了，因此主节点认为没有提交成功。这时候主从数据不一致。

从上面讨论可以看出来，这种依靠主从节点之间确认的方案都是不可行的。本质原因在于：在故障情况下，节点提交和确认包发送是无法保证同时成功的。我们需要通过其他算法来解决数据一次性的问题。接下来，会先讨论分布式存储的 cap 理论和 base 理论，然后再分析共识算法 paxos

# CAP

CAP 理论：分布式系统中，分区网络错误的情况下，可用性，一致性只能二选一

- 分区容忍性：允许系统节点之间的网络发生故障
- 一致性：只要写入成功，后续的所有读操作，都会读到最新的数据；在故障时，读到错误。这里的一致性也就是强一致性。
- 可用性：每次读，从任意节点读，都能读到数据（非错误信息）

大部分情况下，系统节点的网络是正常的，意味着强一致性和可用性能同时实现：从任意节点读，都能读到最新写操作后的数据。在网络故障下，则应该根据业务场景选择一致性或者可用性。那为什么两者不能同时兼得？这里来个证明的思路。

强一致性读是要保证每个节点都能返回最新的数据，那节点如何知道自己存储了最新的数据呢？
一个最直接暴力的方式：写操作时，需要写入所有节点，才算写成功。读数据时，去查询所有节点，比较下，看看自己是不是最新的，如果不是就去更新。 由此可见，强一致性读需要网络通信。在网络错误时候，只有两种选择：1. 直接返回自身的数据，有可能是旧数据，这就是放弃了强一致性 2. 返回错误，确保了强一致性，放弃可用性

# BASE

base 理论：基本可用，软状态，最终一致性

- 基本可用：和 cap 的可用性一样
- 软状态：允许各节点的数据在中间时刻不一致，也就是不能保证强一致性
- 最终一致性：写成功后，只需要保证在若干时间后的所有读操作能读到最新的数据

base 理论就是 cap 理论下选择了可用性，然后提供了最终一致性而不是强一致性

# paxos：提供强一致性的共识算法

再重复下上面提及到的强一致性读：写的时候，写入所有节点，才算写成功。读的时候，读取所有节点，如果数据都存在，才认为数据有效并且最新。这种通过其他人信息才能保证的成功，就是一种共识，也就是 paxos 算法的基石。 paxos 是通过节点之间达成的共识，来判断数据是否真正提交成功，来读取最新的数据。下面简单介绍 paxos 的细节：

- 过半数节点：节点数需要为奇数，过半数是指二分之一往上取整。例如 3 台机器，过半数是 2.
- 写操作：只要过半数节点确认，就算提交成功
- 读操作：节点向过半数节点或者主节点确认自身数据是否最新。这就是论文提到的 Quorum read.

为什么是过半数?

只要保证写入过半数，就可以通过查询过半数而且获取最新数据。举个例子，一共 9 台，偏好 1-9，有一个写操作写了机器 1-5，读操作需要读取过半数，最坏情况下，会读到 5-9，机器 5 就包括了最新信息。

那么，我们用公式来描述这个关系： 我们用 w 代表需要写的节点，r 代表要读的节点，n 代表机器总结点。

- 如果 w+r > n，那么写集合与读结合就会重叠的，从而保证强一致性。 如果 w=1，r=n，那么就是写快读慢，因为读需要咨询所有节点。如果 w=n，r=1.那么就是写慢读快，因为要所有节点写入才算成功，读只需要读自身节点。

# 对账

尽管 paxos 提供了强大的强一致性算法，但我们不能保证实现的正确性，不能仅仅依赖 paxos 来保证正确性。因此，我们可以进行分钟级别的数据对账，把潜在问题暴露出来。

# 简单说下各数据库下的一致性和可用性

mysql

- 全同步复制： 所有从节点写入成功便返回
- 异步复制： 不需要从节点确认，直接返回
- 半同步复制： 一个从节点成功写入 relay，即刻返回
- MGR(mysql group replication)， 基于 paxos。

全同步/异步/半同步保证了可用性牺牲了一致性，而 MGR
保证了强一致性，牺牲可用性

mongodb
保证了最终一致性和可用性

redis
开源版本是基于主从异步复制，在故障时有可能丢失数据
