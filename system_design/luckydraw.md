# 概述

抽奖系统主要分为抽奖和发奖两部分。本文会从限流，并发，数据一致性,缓存,安全策略，分布式事务的角度来展开讨论。

## 限流处理

抽奖有瞬时并发的场景。如果没控制好流量，会导致服务不可用或者数据库不可用。下面会讨论几种限流处理方案。

1.  后端请求限流

    - 接入层限流：根据处理速度决定是否拒绝请求

    - 逻辑层限流：如果业务允许非绝对的公平性，可以进行一些柔性策略，例如对每个请求随机错开活动的开始时间，随机拒绝请求等等

2.  队列限流

    - 对用户的请求进行异步处理。接收到用户请求后直接回复稍后通知，然后把请求放进队列进行异步处理。这样做的好处是可以迅速响应请求，并且可以利用队列控制处理速度，减缓对服务器和数据库的压力。

3.  数据库限流

    - 每个礼品都会有限额，所以我们只需要处理固定数量的请求。 例如限购 100 部特价 iphone，那么每秒最多需要处理 100 个查询数据库端的请求，其余请求可以直接返回失败给客户端。

## 并发处理

发奖前需要判断是否有足够的库存，需要保证获取库存和扣减库存的原子性

1. 扣减库存的方法

   mysql 方式，使用悲观锁：

   ```
   START TRANSACTION

   result = query(SELECT * FROM gift_table WHERE gift_id = 'iphone_id' FOR UPDATE)

   if result.counter > 0 {
       UPDATE gift_table SET counter=counter-1 WHERE val > 0 limit 1
   }

   COMMIT
   ```

   redis 方式：

   ```
   if decrby(gift_counter_key) > 0 {
       process()
   }
   ```

   mysql 使用了悲观锁，而且存储介质是磁盘，所以性能较低，redis 性能会高很多。这里需要考虑，数据库故障情况下，主从数据的一致性

2. 拆分商品，从而降低数据库操作压力

   在 redis 场景下，对于限额 10000 部的特价 iphone，它的 key value 可以表示成 r_iphone:10000. 然而所有请求都落到单一 key 的查询时，这就成了单点的瓶颈。因此
   我们可以把它拆成多个商品来存储，例如 r_iphone_1:10, r_iphone_2:10 来处理. 这里的拆分可以按地区或其他纬度拆分，取决于业务逻辑.

## 数据一致性

更新库存后，需要保证每次读都能读到更新后的结果，否则会引起超发。

上述提及到的 mysql 和 redis 处理方式，需要考虑数据库故障导致主从数据不一致的情况。这里先简单介绍数据库的一些知识点

**强一致性**：只要写入成功，后续的所有读操作，都会读到最新的数据

mysql 提供的 全同步/半同步/异步复制在故障时，都不能保证强一致性。要达到强一致性，需要使用基于 paxos/raft 等一致性算法，例如 mysql 提供的 mysql group replication，微信提供的 phxsql 等等。更多分布式数据库的知识可以查看 [数据库](/fundamental/db.md))

## 缓存处理

用户必然会高频查询商品的库存， 因此要通过缓存避免请求直接落到数据库。然而缓存会牺牲掉数据更新的及时性。

1.  后台进程缓存

    缓存在进程内存或者共享内存

2.  集中式缓存，redis

    从数据库获取库存，更新到 redis。请求只会从 redis 获取缓存结果。

    不同级别的缓存会造成不同级别的数据延时性和准确性。业务可以根据负载情况下进行分级处理

## 安全策略

涉及到钱的时候，就会有恶意请求。因此，需要制定安全策略来阻止

1.  限制单用户访问频率
2.  限制 ip 访问频率
3.  限制单个奖品的兑换频率
4.  限制用户获取奖励的总值
5.  禁止用户互赠礼品
6.  对获奖用户的活跃度和真实性进行判断

## 分布式事务

抽奖有两个步骤，先扣除库存，再发送礼物，这两个操作需要同时成功同时失败。下面这文章会单独介绍 [分布式事务](/system_design/distributed_transaction.md)
