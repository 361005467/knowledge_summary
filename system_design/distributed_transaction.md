# 概述

在微服务的大潮下，分布式事务屡见不鲜. 举个例子，用户转账 100 块给商户。当用户的扣费服务和商户的入账服务属于单独两个服务时，要怎样才能保持两个操作同时成功或者同时取消。

本文会从零开始逐步演进，讨论分布式事务的最终一致性的方案

## 单个事务状态

对于单个事务的状态，有以下三种情况

- 成功
- 失败
  - 当事务失败时，可进行有限次数的重试。超过次数时，则对所有事务进行回滚。回滚重试多次失败时，则记录并进行告警，等待修复
- 超时
  - 超时有可能是事务服务故障了，也可能是事务已经处理成功但回包失败。这种场景，我们需要查询事务的处理状态，以及进行有限次重试。重试多次后，标记为失败状态。事务处理需要保证幂等性，防止多次处理

## 事务可重试和可回滚

从对事务状态的讨论得知，任务需要保证：

1. 可重试：事务可以多次执行，但要保证幂等性，对于相同的订单号不会重复处理

2. 可回滚：提供回滚接口，通过订单号即可回滚对应修改

## 事务状态持久化

从直觉上，我们也许会想出以下方案：

业务服务发起多个事务请求，当任意一个事务处理失败时，则对事务进行有限次数的重试。 当超过重试次数时，对所有事务回滚

然而该方案下，当业务服务故障时，则会丢失目前的事务处理状态。例如，在已经处理扣费但入账失败时，业务服务故障了，来不及做回滚。这样就会丢了整个事务集合的处理状态

因此，我们需要保存事务的处理状态。有了事务状态表后，我们可以安排进程不断从表里获取要处理的事务。

## 整体架构

在上述讨论的基础，我们可以设计以下架构

![架构](/resource/dis_transaction.jpg)

当业务服务接收到分布式事务时，先保存在**全局事务管理器**。
**全局事务处理服务**会轮询**全局事务管理器**，获取事务并调用对应的**单一事务服务**进行处理。

数据库各字段的含义：

1. 业务处理时间戳： **全局事务处理服务**开始处理的时间
2. 状态 1:状态 1 保存事务 1 的处理状态（成功/失败/超时）
3. 整体状态：代表事务集合的处理状态，有以下类型

- 未开始
- 已完成
- 已回滚
- 处理中
  - 这里我们可以设定一个固定的时间值。如果整体业务在处理中，并且超过预设阀值，我们可以认为全局事务处理服务异常，导致没有更新管理器的状态。这时候，该事务集合需要重新处理。
- 不一致
  - 无法完成所有事务的成功和回滚。这时候代表单一事务服务故障，需要人工介入

在这个架构下，就算出现服务故障，也不用人工修复受损业务。

## 可扩展和高可用

- 业务服务，全局事务管理器，全局事务处理服务，单一事务服务：这四类服务都属于无状态服务，可以进行负载均衡容灾
- 全局事务管理器数据库：数据库容灾

## 异常分析

应该会有人产生疑问，在这种架构下，真的可以保证分布式事务的数据一致性吗？并且在故障情况下自愈吗？ 接下来可以考虑几种故障情况

1. 全局事务管理器故障

- 由于做了负债均衡容灾，不存在单点问题

2. 全局事务处理服务故障

- 事务集合 id1 有两个事务，分表是事务 1，事务 2。 全局事务处理服务 1 已经处理完事务 1，然后故障了。
  - 此时事务集合 id1 的整体状态处于处理中。 当另一个全局事务处理服务 2 轮询时，发现了处理时间超过预设时间后，则进行重新处理。由于单一事务服务保证了幂等性，因此不存在问题。

3. 单一事务故障

- 单一事务故障，导致整体事务无法进行整体的完成和回退，处于不一致状态
  - 这种情况需要人工干预。在单一事务恢复后，人工将整体状态从不一致改成未开始

## 总结

该方案可以实现分布式事务下的最终一致性，以及提供了分布式事务受损自愈的能力
