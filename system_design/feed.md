# 概述

joox 里存在粉丝关系链，用户需要获取自己好友发布的 k 歌视频，也就是题目中说到的 feed。 本文会讨论下技术方案。

## 难点

拉取 feed，不就是读数据。第一眼很简单，直接获取用户的所有关注对象，然后读取各自发布的 feed，聚合一下，返回，然后上线完了。上线后，发现耗时太久，完蛋了。

## 方案

显然，暴力拉取的网络耗时久，聚合的计算量也大，必须有优化的方案。看了下同行的文章，总的来说分为三类，读扩散，写扩散，读写结合

### 读扩散

用户先拉取关注对象集合，然后拉取关注对象的发布作品的 feedID 和时间戳。然后时间倒序，然后分页查询过滤。最后根据 feedID 查数据库，返回。

每个用户的作品 feedID 可以根据时间权重，缓存在 redis 的 sorted set 里面。 用户读扩散时，从关注用户的 sorted set 里获取 feedID。

- 优点： 不需要冗余数据
- 缺点： 拉取关注用户的 feed 索引有严重网络耗时，排序会 cpu 耗时，导致单次请求耗时过久。

### 写扩散

给每个用户维护一个订阅列表。当用户发 feed 时，给他的所有粉丝的订阅列表都追加一个 feedID。

可以看出，其实这个方案也是涉及很多网络 io，只是这个 io 是发生在用户读之前，用户无感知。

- 优点：减少用户请求耗时
- 缺点：1.数据大量冗余。2.更新 feed 比较麻烦，要去更新每个粉丝的订阅列表

显然，对于有钱的大公司，存储不是问题。而写扩散对用户体验更好，用就完事了。但是，对于有追求的软件工程师，优化是必不可少的。 接下来看下优化点。

#### 降低存储成本

订阅列表的数据是按时间戳排序的，很自然，较新的数据才会被高频访问，旧数据我们可以放进更便宜的存储设备。腾讯的 tlist 提供了这样的存储。 简单来说，tlist 是一个 key value 存储，value 是一个列表，所以很适合数据追加。tlist 也具备冷热分离的能力，会迁移旧数据到便宜设备。当然，做为 key value 存储，单点的并发能力都是有限的。对于 k 歌视频来说，写少读多，所以没问题。

#### 读写结合

对于用户体验来说，写扩散固然更好，但我们要思考值不值得。对于不活跃的用户，给他提前写了，他也不会打开看。对于大 v 来说，他发一个 k 歌，就需要给他的千万粉丝去写，去冗余，代价有点大。 所以，我们可以权衡一下，采用下面的优化点

- 对于不活跃的用户，采取读扩散的方式。 活跃用户才取写扩散

- 大 v 的作品需要主动读（读扩散），普通用户的作品则提前写
  - 具体做法：用户的订阅列表是已经写好普通用户的作品，只需要补充大 v 的作品就好。

### 缓存优化

获取订阅列表后，则需求根据 feedID 来拉数据。我们可以用 redis 来缓存热点数据。对于大 v 的作品，单个 key 缓存是不够的。因此我们可以用多个 key 来缓存，例如 feedID_1, feedID_2,feedID_3

# 总结

从本质来看，写扩散是提前写好数据，冗余多份，空间换取时间，从而提高性能。 而读扩散不能提前存储，所以耗时更久。当涉及到存储，我们可以思考存储的数据结构，从而选用更合适的数据库。 另外，结合业务的特性，我们可以做些取舍。正因为粉丝多，才会冗余多，所以对于大 v 就不冗余了。对于非核心用户，没必要做优化，所以也不会提前写。

# 参考

- https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961214&idx=1&sn=5e80ad6f2a278529c395e445029d8f63&chksm=bd2d02a28a5a8bb4f8622b1bff1cf87fc9adb510117dd2cf93fedd01fdc5d5ace7557a03f3b1&scene=21#wechat_redirect

- http://www.360doc.com/content/17/1205/18/38884510_710231638.shtml
