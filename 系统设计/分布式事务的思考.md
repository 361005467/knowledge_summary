# 概述

在微服务的大潮下，分布式事务屡见不鲜. 举个例子，用户转账 100 块给商户。当用户的扣费服务和商户的转账服务属于单独两个服务时，要怎样才能保持两个操作同时成功或者同时取消。换句话说，如何保证任务集合里的所有任务同时成功或同时取消

本文会从零开始逐步演进，讨论分布式事务的最终一致性的方案

## 单个任务状态

对于单个任务的状态，有以下三种情况

- 成功
- 失败
  - 当任务失败时，可进行有限次数的重试。超过次数时，则对所有任务进行回滚。回滚重试多次失败时，则记录并进行告警，等待修复
- 超时
  - 超时有可能是微服务宕机了，也可能是任务已经处理成功但回包失败。这种场景，我们只能对任务进行有限次重试，重试多次后，标记为失败状态。任务处理需要保证幂等性，防止多次处理

## 任务处理的幂等性和可回滚

从对任务状态的讨论得知，任务需要保证：

1. 可重试：任务可以多次执行，但要保证幂等性，对于相同的订单号不会重复处理

2. 可回滚：提供回滚接口，通过订单号即可回滚对应修改

## 任务状态持久化

从直觉上，我们也许会想出以下方案：

业务进程发起多个微服务请求，当任意一个服务处理失败时，则对服务进行有限次数的重试。 当超过重试次数时，对所有业务回滚

然而该方案下，当业务进程宕机时，则会丢失目前的处理状态。例如，在已经处理扣费但转账失败时，进程崩溃了，来不及做回滚

因此，我们需要保存任务的处理状态。这里可以选用数据库来保存信息。有了任务状态表后，我们可以安排进程不断从表里获取要处理的任务。

## 总结

通过任务的重试回滚，以及任务状态的保存，我们就可以保证分布式事务的最终一致性
